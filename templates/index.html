<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CapsWriter Web Client (Flask)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <style>
        ::-webkit-scrollbar { width: 6px; height: 6px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: #475569; border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: #64748b; }
        .time-input { background: transparent; border-bottom: 1px solid #4b5563; text-align: center; width: 5.5rem; font-family: monospace; color: #93c5fd; font-size: 0.875rem; transition: all 0.2s; }
        .time-input:focus { border-color: #3b82f6; outline: none; color: #fff; }
        .drag-overlay { pointer-events: none; opacity: 0; transition: opacity 0.2s; }
        .drag-active .drag-overlay { opacity: 1; }
        .drag-active { border-color: #3b82f6 !important; background-color: rgba(30, 41, 59, 0.8) !important; }
        
        /* ÂºÄÂÖ≥Ê†∑Âºè */
        .toggle-checkbox:checked { right: 0; border-color: #3b82f6; }
        .toggle-checkbox:checked + .toggle-label { background-color: #3b82f6; }
    </style>
</head>
<body class="bg-slate-900 text-slate-200 h-screen overflow-hidden flex flex-col font-sans">
    
    {% raw %}
    <div id="app" class="flex flex-col h-full max-w-[1600px] mx-auto w-full p-4 gap-4">
        
        <!-- Â§¥ÈÉ® -->
        <header class="flex justify-between items-center bg-slate-800 p-4 rounded-xl shadow-lg border border-slate-700 shrink-0">
            <h1 class="text-xl font-bold tracking-tight text-white flex items-center gap-2">
                <span class="text-blue-500">CapsWriter</span> Flask
            </h1>
            <div class="flex items-center gap-4">
                <!-- ÊõøÊç¢Â§ÑÁêÜÂºÄÂÖ≥ÁªÑ -->
                <div class="flex items-center gap-4 bg-slate-900/50 p-2 rounded-lg border border-slate-700/50">
                    <span class="text-xs text-slate-400 font-bold px-1">Â§ÑÁêÜÂºÄÂÖ≥:</span>
                    <label class="flex items-center cursor-pointer gap-2" title="Ëã±ÊñáÁÉ≠ËØçÊõøÊç¢">
                        <span class="text-xs text-slate-300">EnÁÉ≠ËØç</span>
                        <div class="relative inline-block w-8 h-4 align-middle select-none transition duration-200 ease-in">
                            <input type="checkbox" v-model="toggles.enHot" class="toggle-checkbox absolute block w-4 h-4 rounded-full bg-white border-4 appearance-none cursor-pointer transition-all duration-300 left-0 checked:left-4 top-0"/>
                            <div class="toggle-label block overflow-hidden h-4 rounded-full bg-slate-700 cursor-pointer"></div>
                        </div>
                    </label>
                    <label class="flex items-center cursor-pointer gap-2" title="‰∏≠ÊñáÁÉ≠ËØçÊõøÊç¢">
                        <span class="text-xs text-slate-300">ZhÁÉ≠ËØç</span>
                        <div class="relative inline-block w-8 h-4 align-middle select-none transition duration-200 ease-in">
                            <input type="checkbox" v-model="toggles.zhHot" class="toggle-checkbox absolute block w-4 h-4 rounded-full bg-white border-4 appearance-none cursor-pointer transition-all duration-300 left-0 checked:left-4 top-0"/>
                            <div class="toggle-label block overflow-hidden h-4 rounded-full bg-slate-700 cursor-pointer"></div>
                        </div>
                    </label>
                    <label class="flex items-center cursor-pointer gap-2" title="ËßÑÂàôÊõøÊç¢">
                        <span class="text-xs text-slate-300">ËßÑÂàô</span>
                        <div class="relative inline-block w-8 h-4 align-middle select-none transition duration-200 ease-in">
                            <input type="checkbox" v-model="toggles.rule" class="toggle-checkbox absolute block w-4 h-4 rounded-full bg-white border-4 appearance-none cursor-pointer transition-all duration-300 left-0 checked:left-4 top-0"/>
                            <div class="toggle-label block overflow-hidden h-4 rounded-full bg-slate-700 cursor-pointer"></div>
                        </div>
                    </label>
                </div>

                <!-- Á´ØÂè£ÈÖçÁΩÆ -->
                <div class="flex items-center gap-3 bg-slate-900/50 p-1.5 rounded-lg border border-slate-700/50">
                    <input v-model="config.host" class="bg-transparent text-sm px-3 py-1.5 outline-none text-slate-300 w-32 text-center" placeholder="127.0.0.1">
                    <span>:</span>
                    <input v-model="config.port" class="bg-transparent text-sm px-3 py-1.5 outline-none text-slate-300 w-16 text-center" placeholder="6016">
                </div>
            </div>
        </header>

        <div class="flex flex-col lg:flex-row gap-4 h-full overflow-hidden min-h-0">
            <!-- Â∑¶‰æßÊéßÂà∂Âå∫ -->
            <div class="flex-1 flex flex-col gap-4 min-w-0 h-full">
                <!-- ËßÜÈ¢ëÂå∫Âüü -->
                <div 
                    class="relative bg-black rounded-xl overflow-hidden border border-slate-700 shadow-2xl flex-1 flex flex-col justify-center transition-colors duration-200 group"
                    :class="{ 'drag-active': isDragging }"
                    @dragover.prevent="isDragging = true"
                    @dragleave.prevent="isDragging = false"
                    @drop.prevent="handleDrop"
                >
                    <div class="drag-overlay absolute inset-0 bg-blue-500/20 backdrop-blur-sm z-50 flex flex-col items-center justify-center border-4 border-blue-500 border-dashed rounded-xl m-1">
                        <p class="text-white text-2xl font-bold drop-shadow-md">ÈáäÊîæÊñá‰ª∂‰ª•Âä†ËΩΩ</p>
                    </div>

                    <div v-if="!mediaUrl" class="absolute inset-0 flex flex-col items-center justify-center cursor-pointer hover:bg-white/5 transition-colors z-10" @click="$refs.fileInput.click()">
                        <p class="text-slate-400 font-medium group-hover:text-slate-200">ÁÇπÂáªÊàñÊãñÊãΩÈÄâÊã©Èü≥ËßÜÈ¢ëÊñá‰ª∂</p>
                        <p v-if="subtitles.length > 0" class="text-xs text-orange-400 mt-2">Â∑≤ÊÅ¢Â§ç‰∏äÊ¨°Â≠óÂπïËÆ∞ÂΩïÔºåËØ∑ÈáçÊñ∞Âä†ËΩΩÂØπÂ∫îÁöÑÈü≥ËßÜÈ¢ëÊñá‰ª∂</p>
                    </div>
                    
                    <video v-else ref="videoPlayer" class="w-full h-full object-contain z-20" controls :src="mediaUrl" @loadedmetadata="onMediaLoaded"></video>
                    <input type="file" ref="fileInput" class="hidden" accept="video/*,audio/*" @change="handleFileSelect">
                </div>

                <!-- Â∫ïÈÉ®ÊéßÂà∂Êù° -->
                <div class="bg-slate-800 p-5 rounded-xl border border-slate-700 shrink-0">
                    <div class="flex justify-between items-center mb-4">
                        <div class="flex flex-col min-w-0">
                            <span class="text-white font-semibold truncate">{{ currentFile ? currentFile.name : 'Êú™ÈÄâÊã©Êñá‰ª∂' }}</span>
                            <div class="flex gap-3 text-xs text-slate-500 mt-1">
                                <span v-if="currentFile">{{ formatFileSize(currentFile.size) }}</span>
                                <!-- ÊòæÁ§∫ÂÆûÈôÖËÄóÊó∂ -->
                                <span v-if="processingTime > 0" class="text-emerald-400 font-bold">
                                    ÂÆûÈôÖËÄóÊó∂: {{ processingTime.toFixed(2) }}s
                                </span>
                                <!-- ÊòæÁ§∫È¢Ñ‰º∞ËÄóÊó∂ËåÉÂõ¥ -->
                                <span v-else-if="mediaDuration > 0" class="text-blue-400">
                                    È¢ÑËÆ°ËÄóÊó∂: {{ (mediaDuration / 72).toFixed(1) }}s ~ {{ (mediaDuration / 10).toFixed(1) }}s
                                </span>
                            </div>
                        </div>
                        <span class="text-blue-400 font-bold ml-4">{{ progress }}s</span>
                    </div>
                    <button @click="processAudio" :disabled="!currentFile || isProcessing" class="w-full py-3 rounded-lg font-bold text-white transition-all shadow-lg active:scale-[0.99]" :class="isProcessing ? 'bg-slate-600 cursor-not-allowed' : 'bg-gradient-to-r from-blue-600 to-blue-500 hover:from-blue-500 hover:to-blue-400'">
                        {{ isProcessing ? status : 'ÂºÄÂßãËΩ¨ÂΩï' }}
                    </button>
                    <div v-if="errorMsg" class="mt-3 text-red-400 text-xs bg-red-900/20 p-2 rounded border border-red-900/50">{{ errorMsg }}</div>
                </div>
            </div>

            <!-- Âè≥‰æßÂ≠óÂπïÂå∫ -->
            <div class="lg:w-[580px] flex flex-col bg-slate-800 rounded-xl border border-slate-700 shadow-xl overflow-hidden h-full">
                
                <!-- Â∑•ÂÖ∑Ê†è 1: ÁøªËØë‰∏éÊñá‰ª∂ÁºñËæë -->
                <div class="p-3 border-b border-slate-700 bg-slate-800/95 backdrop-blur z-20 flex flex-col gap-3">
                    <div class="flex justify-between items-center">
                        <div class="flex gap-2">
                             <button @click="openEditor('hot-en.txt')" class="text-xs bg-slate-700 hover:bg-slate-600 text-slate-300 px-2 py-1 rounded border border-slate-600">EnÁÉ≠ËØç</button>
                             <button @click="openEditor('hot-zh.txt')" class="text-xs bg-slate-700 hover:bg-slate-600 text-slate-300 px-2 py-1 rounded border border-slate-600">ZhÁÉ≠ËØç</button>
                             <button @click="openEditor('hot-rule.txt')" class="text-xs bg-slate-700 hover:bg-slate-600 text-slate-300 px-2 py-1 rounded border border-slate-600">ËßÑÂàô</button>
                        </div>
                        <div class="flex items-center gap-2">
                            <select v-model="targetLang" class="bg-slate-900 text-xs text-slate-300 border border-slate-600 rounded px-2 py-1 focus:outline-none focus:border-blue-500">
                                <option value="en">English</option>
                                <option value="zh">‰∏≠Êñá</option>
                                <option value="ja">Êó•Êú¨Ë™û</option>
                                <option value="ko">ÌïúÍµ≠Ïñ¥</option>
                            </select>
                            <button @click="translateAll" :disabled="!subtitles.length" class="text-xs bg-indigo-600 hover:bg-indigo-500 text-white px-3 py-1 rounded transition-colors flex items-center gap-1">
                                ÁøªËØëÂÖ®Êñá
                            </button>
                        </div>
                    </div>
                </div>

                <!-- Â∑•ÂÖ∑Ê†è 2: Âü∫Á°ÄÊìç‰Ωú‰∏éÂØºÂá∫ËÆæÁΩÆ -->
                <div class="px-3 py-2 border-b border-slate-700 bg-slate-800 flex flex-col gap-2 text-xs">
                    <div class="flex justify-between items-center">
                        <span class="text-slate-500 font-mono">{{ subtitles.length }} Lines</span>
                        <div class="flex gap-2">
                             <button @click="insertAtCurrent" :disabled="!mediaUrl" class="bg-blue-600/20 hover:bg-blue-600 text-blue-400 hover:text-white border border-blue-600/30 px-2 py-1 rounded transition-all">ÊèíÂÖ•</button>
                        </div>
                    </div>
                    
                    <!-- ÂØºÂá∫Âå∫Âüü -->
                    <div class="flex items-center justify-between bg-slate-900/50 p-2 rounded border border-slate-700/50">
                        <div class="flex items-center gap-2">
                            <label class="flex items-center cursor-pointer gap-1 select-none" title="ÂØºÂá∫SRTÊó∂ÁßªÈô§Êú´Â∞æÊåáÂÆöÊ†áÁÇπ">
                                <input type="checkbox" v-model="exportConfig.cleanSrt" class="rounded bg-slate-700 border-slate-600 text-blue-500 focus:ring-0 w-3 h-3">
                                <span class="text-slate-400">SRTÂéªÊ†áÁÇπ</span>
                            </label>
                            <input v-if="exportConfig.cleanSrt" v-model="exportConfig.punctuation" class="bg-slate-800 border border-slate-600 text-slate-300 px-1 py-0.5 rounded w-16 text-center outline-none focus:border-blue-500" placeholder="Ôºå„ÄÇ,." title="ËæìÂÖ•Ë¶ÅÁßªÈô§ÁöÑÁªìÂ∞æÁ¨¶Âè∑">
                        </div>
                        <div class="flex gap-1">
                            <button @click="exportTXT" :disabled="!subtitles.length" class="bg-slate-700 hover:bg-slate-600 text-slate-300 px-2 py-1 rounded transition-all border border-slate-600">TXT</button>
                            <button @click="exportJSON" :disabled="!subtitles.length" class="bg-slate-700 hover:bg-slate-600 text-slate-300 px-2 py-1 rounded transition-all border border-slate-600">JSON</button>
                            <button @click="exportSRT" :disabled="!subtitles.length" class="bg-green-600/20 hover:bg-green-600 text-green-400 hover:text-white border border-green-600/30 px-2 py-1 rounded transition-all">SRT</button>
                        </div>
                    </div>
                </div>
                
                <!-- ÂàóË°® -->
                <div class="flex-1 overflow-y-auto p-2 space-y-2 relative scroll-smooth" ref="subtitleList">
                    <div v-if="subtitles.length === 0" class="h-full flex flex-col items-center justify-center text-slate-500 opacity-50">
                        <p class="text-sm">ÊöÇÊó†Â≠óÂπïÊï∞ÊçÆ</p>
                    </div>

                    <div v-for="(sub, idx) in subtitles" 
                         :key="idx" 
                         class="group bg-slate-900/40 hover:bg-slate-900/80 border border-slate-700/50 hover:border-slate-600 rounded-lg p-3 transition-all duration-200 cursor-pointer"
                         @click="seekTo(sub.start)"
                    >
                        <div class="flex items-center gap-2 mb-2">
                            <span class="text-slate-500 w-6 text-right text-xs font-mono select-none">{{ idx + 1 }}</span>
                            <div class="relative flex items-center">
                                <input v-model="sub.start" class="time-input" @click.stop @input.stop>
                                <button @click.stop="syncTime(idx, 'start')" class="ml-1 text-slate-600 hover:text-blue-400 opacity-0 group-hover:opacity-100 transition-opacity">‚è±Ô∏è</button>
                            </div>
                            <span class="text-slate-600 text-xs">‚Üí</span>
                            <div class="relative flex items-center">
                                <input v-model="sub.end" class="time-input" @click.stop @input.stop>
                                <button @click.stop="syncTime(idx, 'end')" class="ml-1 text-slate-600 hover:text-blue-400 opacity-0 group-hover:opacity-100 transition-opacity">‚è±Ô∏è</button>
                            </div>
                            <div class="flex-1"></div>
                            <button @click.stop="removeSub(idx)" class="text-slate-600 hover:text-red-400 opacity-0 group-hover:opacity-100 transition-opacity">üóëÔ∏è</button>
                        </div>
                        <textarea v-model="sub.text" rows="1" class="w-full bg-transparent text-slate-200 text-sm focus:outline-none resize-none leading-relaxed pl-8 border-l-2 border-transparent focus:border-blue-500/50 transition-colors" @click.stop @input="autoResize"></textarea>
                    </div>
                    <div class="h-10"></div>
                </div>
            </div>
        </div>

        <!-- Êñá‰ª∂ÁºñËæëÂô®Ê®°ÊÄÅÊ°Ü -->
        <div v-if="editor.visible" class="fixed inset-0 z-[100] bg-black/80 backdrop-blur-sm flex items-center justify-center p-4">
            <div class="bg-slate-800 w-full max-w-2xl rounded-xl border border-slate-600 shadow-2xl flex flex-col h-[80vh]">
                <div class="p-4 border-b border-slate-700 flex justify-between items-center">
                    <h3 class="font-bold text-white">ÁºñËæë: {{ editor.filename }}</h3>
                    <button @click="editor.visible = false" class="text-slate-400 hover:text-white">‚úï</button>
                </div>
                <textarea v-model="editor.content" class="flex-1 bg-slate-900 p-4 font-mono text-sm text-slate-300 focus:outline-none resize-none" spellcheck="false"></textarea>
                <div class="p-4 border-t border-slate-700 flex justify-end gap-3">
                    <button @click="editor.visible = false" class="px-4 py-2 rounded text-slate-300 hover:bg-slate-700">ÂèñÊ∂à</button>
                    <button @click="saveFile" class="px-4 py-2 rounded bg-blue-600 hover:bg-blue-500 text-white font-medium">‰øùÂ≠ò‰øÆÊîπ</button>
                </div>
            </div>
        </div>

    </div>
    {% endraw %}

    <script>
        const { createApp, ref, nextTick, computed, watch, onMounted } = Vue;

        createApp({
            setup() {
                // Áä∂ÊÄÅÂÆö‰πâ
                const config = ref({ host: '127.0.0.1', port: '6016' });
                const currentFile = ref(null);
                const mediaUrl = ref('');
                const mediaDuration = ref(0);
                const status = ref('Â∞±Áª™');
                const progress = ref(0);
                const isProcessing = ref(false);
                const processingTime = ref(0); // Êñ∞Â¢ûÔºöÁî®‰∫éËÆ∞ÂΩïÂÆûÈôÖËÄóÊó∂
                const errorMsg = ref('');
                const subtitles = ref([]);
                const videoPlayer = ref(null);
                const isDragging = ref(false);
                
                const targetLang = ref('en');
                const toggles = ref({ enHot: false, zhHot: false, rule: false });
                const exportConfig = ref({ cleanSrt: false, punctuation: '"Ôºå„ÄÇ,.' });
                const editor = ref({ visible: false, filename: '', content: '' });

                // Êú¨Âú∞Â≠òÂÇ®ÈîÆÂêç
                const STORAGE_KEY = 'cw_flask_app_state_v1';

                // UUID ÁîüÊàê
                const uuidv4 = () => 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {
                    const r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
                    return v.toString(16);
                });

                // --- Êú¨Âú∞Â≠òÂÇ®ÈÄªËæë ---
                const saveState = () => {
                    const state = {
                        config: config.value,
                        toggles: toggles.value,
                        targetLang: targetLang.value,
                        exportConfig: exportConfig.value,
                        subtitles: subtitles.value // ‰øùÂ≠òÂ≠óÂπïÁªìÊûú
                    };
                    localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
                };

                const loadState = () => {
                    const saved = localStorage.getItem(STORAGE_KEY);
                    if (saved) {
                        try {
                            const parsed = JSON.parse(saved);
                            if (parsed.config) config.value = parsed.config;
                            if (parsed.toggles) toggles.value = parsed.toggles;
                            if (parsed.targetLang) targetLang.value = parsed.targetLang;
                            if (parsed.exportConfig) exportConfig.value = parsed.exportConfig;
                            if (parsed.subtitles && Array.isArray(parsed.subtitles)) {
                                subtitles.value = parsed.subtitles;
                                nextTick(() => document.querySelectorAll('textarea').forEach(el => autoResize({target: el})));
                            }
                        } catch (e) { console.error('Failed to load state', e); }
                    }
                };

                // ÁõëÂê¨ÂèòÂåñËá™Âä®‰øùÂ≠ò
                watch([config, toggles, targetLang, exportConfig, subtitles], () => {
                    saveState();
                }, { deep: true });

                onMounted(() => {
                    loadState();
                });

                // --- ËßÜÈ¢ëÁõ∏ÂÖ≥ ---
                const onMediaLoaded = (e) => {
                    mediaDuration.value = e.target.duration;
                };

                // --- Flask ‰∫§‰∫í ---
                const openEditor = async (filename) => {
                    editor.value.filename = filename;
                    editor.value.visible = true;
                    try {
                        const res = await fetch(`/api/file/${filename}`);
                        const data = await res.json();
                        if(data.error) throw new Error(data.error);
                        editor.value.content = data.content;
                    } catch (e) { alert('Âä†ËΩΩÊñá‰ª∂Â§±Ë¥•: ' + e.message); }
                };

                const saveFile = async () => {
                    try {
                        const res = await fetch(`/api/file/${editor.value.filename}`, {
                            method: 'POST',
                            headers: {'Content-Type': 'application/json'},
                            body: JSON.stringify({ content: editor.value.content })
                        });
                        const data = await res.json();
                        if(data.success) editor.value.visible = false;
                        else alert('‰øùÂ≠òÂ§±Ë¥•: ' + data.error);
                    } catch (e) { alert('‰øùÂ≠òÂºÇÂ∏∏: ' + e.message); }
                };

                const translateAll = async () => {
                    if(!subtitles.value.length) return;
                    const originalStatus = status.value;
                    status.value = 'Ê≠£Âú®ÁøªËØë...';
                    const promises = subtitles.value.map(async (sub) => {
                        try {
                            const res = await fetch('/api/translate', {
                                method: 'POST',
                                headers: {'Content-Type': 'application/json'},
                                body: JSON.stringify({ text: sub.text, lang: targetLang.value })
                            });
                            const data = await res.json();
                            sub.text = `${sub.text}\n${data.result}`;
                        } catch(e) { console.error(e); }
                    });
                    await Promise.all(promises);
                    status.value = originalStatus;
                    nextTick(() => document.querySelectorAll('textarea').forEach(el => autoResize({target: el})));
                };

                const processTextViaBackend = async (text) => {
                    const activeTypes = [];
                    if(toggles.value.enHot) activeTypes.push('en-hot');
                    if(toggles.value.zhHot) activeTypes.push('zh-hot');
                    if(toggles.value.rule) activeTypes.push('rule');
                    if(activeTypes.length === 0) return text;
                    try {
                        const res = await fetch('/api/process_text', {
                            method: 'POST',
                            headers: {'Content-Type': 'application/json'},
                            body: JSON.stringify({ text: text, types: activeTypes })
                        });
                        const data = await res.json();
                        return data.result;
                    } catch(e) { return text; }
                };

                // --- Âü∫Á°ÄÈÄªËæë ---
                const handleFileSelect = (e) => processFile(e.target.files[0]);
                const handleDrop = (e) => { isDragging.value = false; processFile(e.dataTransfer.files[0]); };
                const processFile = (file) => {
                    if (file) { 
                        currentFile.value = file; 
                        mediaUrl.value = URL.createObjectURL(file); 
                        // Êñ∞Êñá‰ª∂ÈáçÁΩÆÂ≠óÂπïÔºåÈô§Èùû‰Ω†ÊÉ≥ËøΩÂä†ÔºüÈÄöÂ∏∏ÊòØÊ∏ÖÁ©∫
                        subtitles.value = []; 
                        errorMsg.value = ''; 
                        progress.value = 0; 
                    }
                };
                const formatFileSize = (bytes) => {
                    if (bytes === 0) return '0 B';
                    const k = 1024; const sizes = ['B', 'KB', 'MB', 'GB'];
                    const i = Math.floor(Math.log(bytes) / Math.log(k));
                    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
                };

                const processAudio = async () => {
                    if (!currentFile.value) return;
                    isProcessing.value = true;
                    errorMsg.value = '';
                    subtitles.value = [];
                    progress.value = 0;
                    processingTime.value = 0; // ÈáçÁΩÆÂÆûÈôÖËÄóÊó∂
                    const startTime = Date.now(); // ËÆ∞ÂΩïÂºÄÂßãÊó∂Èó¥

                    try {
                        status.value = 'ÊèêÂèñÈü≥È¢ë...';
                        const fileBuffer = await currentFile.value.arrayBuffer();
                        const audioCtx = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 16000 });
                        const audioBuffer = await audioCtx.decodeAudioData(fileBuffer);
                        const pcmData = audioBuffer.getChannelData(0); 

                        status.value = 'ËøûÊé•ÊúçÂä°Á´Ø...';
                        const ws = new WebSocket(`ws://${config.value.host}:${config.value.port}`);

                        const timerId = setInterval(() => {
                            const endTime = Date.now();
                            progress.value = (endTime - startTime) / 1000;
                        }, 1000);
                        
                        ws.onopen = async () => {
                            status.value = 'ËΩ¨ÂΩï‰∏≠...';
                            const taskId = uuidv4();
                            const chunkSize = 16000 * 60; 
                            const float32ToByteString = (arr) => {
                                const buffer = new ArrayBuffer(arr.length * 4);
                                const view = new DataView(buffer);
                                for(let i=0; i<arr.length; i++) view.setFloat32(i*4, arr[i], true); 
                                return new Uint8Array(buffer).reduce((d, b) => d + String.fromCharCode(b), '');
                            };
                            let offset = 0;
                            while (offset < pcmData.length) {
                                if (ws.readyState !== 1) break;
                                const end = Math.min(offset + chunkSize, pcmData.length);
                                const chunk = pcmData.slice(offset, end);
                                ws.send(JSON.stringify({
                                    task_id: taskId, seg_duration: chunkSize/16000, seg_overlap: 2, is_final: end >= pcmData.length,
                                    time_start: Date.now()/1000, time_frame: Date.now()/1000, source: 'file',
                                    data: btoa(float32ToByteString(chunk))
                                }));
                                offset = end;
                                await new Promise(r => setTimeout(r, 10));
                            }
                        };

                        ws.onmessage = async (e) => {
                            try {
                                const data = JSON.parse(e.data);
                                if (data.is_final && data.tokens) {
                                    if(toggles.value.enHot || toggles.value.zhHot || toggles.value.rule) {
                                        data.text = await processTextViaBackend(data.text);
                                    }
                                    parseResult(data);

                                    clearInterval(timerId); 
                                    
                                    // ËÆ°ÁÆóÂπ∂ÊòæÁ§∫ÂÆûÈôÖËÄóÊó∂
                                    const endTime = Date.now();
                                    processingTime.value = (endTime - startTime) / 1000;
                                    progress.value = processingTime.value;
                                    
                                    status.value = 'ÂÆåÊàê'; ws.close(); isProcessing.value = false;
                                }
                            } catch (err) { console.error(err); }
                        };
                        ws.onerror = () => { isProcessing.value = false; errorMsg.value = 'ËøûÊé•Â§±Ë¥•'; };
                    } catch (err) { errorMsg.value = err.message; isProcessing.value = false; }
                };

                const parseResult = (data) => {
                    const newSubs = [];
                    const parts = data.text.split(/([Ôºå„ÄÇÔºüÔºÅ?ÔºÅ,.?!])/).filter(s => s);
                    let tokenIndex = 0;
                    let isNewSentence = true;
                    for (let i = 0; i < parts.length; i++) {
                        const part = parts[i];
                        if (!/^[Ôºå„ÄÇÔºüÔºÅ?ÔºÅ,.?!]$/.test(part)) {
                            let len = part.length;
                            if (tokenIndex + len <= data.timestamps.length) {
                                const start = tokenIndex > 0 ? data.timestamps[tokenIndex - 1] : 0;
                                const end = data.timestamps[tokenIndex + len - 1];
                                if (isNewSentence) {
                                    newSubs.push({ start: formatTime(start), end: formatTime(end), text: part });
                                    isNewSentence = false;
                                } else {
                                    newSubs[newSubs.length - 1].end = formatTime(end);
                                    newSubs[newSubs.length - 1].text += part;
                                }
                                tokenIndex += len;
                            }
                        } else {
                            if (newSubs.length) { newSubs[newSubs.length - 1].text += part; isNewSentence = true; }
                        }
                    }
                    subtitles.value = newSubs;
                    nextTick(() => document.querySelectorAll('textarea').forEach(el => autoResize({target: el})));
                };

                const formatTime = (s) => {
                    if (isNaN(s)) return "00:00:00,000";
                    const d = new Date(0); d.setMilliseconds(s * 1000);
                    return d.toISOString().substr(11, 12).replace('.', ',');
                };

                const insertAtCurrent = () => {
                    if (!videoPlayer.value) return;
                    const t = formatTime(videoPlayer.value.currentTime);
                    subtitles.value.push({ start: t, end: t, text: '' });
                    nextTick(() => { 
                        const list = document.querySelector('.overflow-y-auto'); list.scrollTop = list.scrollHeight; 
                    });
                };
                const syncTime = (i, type) => { if (videoPlayer.value) subtitles.value[i][type] = formatTime(videoPlayer.value.currentTime); };
                const removeSub = (i) => { if(confirm('Âà†Èô§Ê≠§Ë°å?')) subtitles.value.splice(i, 1); };
                
                const seekTo = (t) => { 
                    if(!videoPlayer.value) return; 
                    const [h,m,s] = t.replace(',','.').split(':'); 
                    videoPlayer.value.currentTime = parseFloat(h)*3600 + parseFloat(m)*60 + parseFloat(s); 
                    videoPlayer.value.pause();
                };
                
                const autoResize = (e) => { e.target.style.height = 'auto'; e.target.style.height = e.target.scrollHeight + 'px'; };
                
                const downloadFile = (content, ext) => {
                    const a = document.createElement('a');
                    a.href = URL.createObjectURL(new Blob([content], {type: 'text/plain'}));
                    a.download = (currentFile.value?.name || 'export') + ext;
                    a.click();
                };

                const exportSRT = () => {
                    let c = '';
                    subtitles.value.forEach((s, i) => {
                        let text = s.text;
                        // ‰ªÖÂú®ÂØºÂá∫SRT‰∏îÂºÄÂÖ≥ÂºÄÂêØÊó∂Â§ÑÁêÜÊ†áÁÇπ
                        if (exportConfig.value.cleanSrt && exportConfig.value.punctuation) {
                            try {
                                const chars = exportConfig.value.punctuation.split('').map(char => '\\' + char).join('|');
                                const regex = new RegExp(`[${chars}]+$`, 'g');
                                text = text.replace(regex, '');
                            } catch (e) { console.error('Regex error', e); }
                        }
                        c += `${i+1}\n${s.start} --> ${s.end}\n${text}\n\n`;
                    });
                    downloadFile(c, '.srt');
                };

                const exportTXT = () => {
                    let c = subtitles.value.map(s => s.text).join('\n');
                    downloadFile(c, '.txt');
                };

                const exportJSON = () => {
                    downloadFile(JSON.stringify(subtitles.value, null, 2), '.json');
                };

                return { 
                    config, currentFile, mediaUrl, mediaDuration, status, progress, isProcessing, processingTime, subtitles, errorMsg, videoPlayer, isDragging,
                    toggles, targetLang, editor, exportConfig,
                    processAudio, exportSRT, exportTXT, exportJSON, autoResize, handleFileSelect, handleDrop, formatFileSize, onMediaLoaded,
                    insertAtCurrent, syncTime, removeSub, seekTo,
                    openEditor, saveFile, translateAll
                };
            }
        }).mount('#app');
    </script>
</body>
</html>